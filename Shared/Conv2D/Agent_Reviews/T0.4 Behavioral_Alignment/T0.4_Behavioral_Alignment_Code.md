# Behavioral Alignment Framework â€” Code Stubs

## Intent Encoder
```python
class IntentEncoder(nn.Module):
    def __init__(self, in_dim, hidden_dim, num_intents=4):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(in_dim, hidden_dim), nn.ReLU(),
            nn.Linear(hidden_dim, num_intents)
        )
    def forward(self, x):
        logits = self.net(x)
        return torch.softmax(logits, dim=-1), logits
```

## Behavior Library (YAML/JSON example)
```yaml
behaviors:
  rest:
    duty: [0.95, 1.0]
    spectral: {A1A2: 0.0}
  walk:
    duty: [0.55, 0.75]
    spectral: {A1A2: 2-3}
  trot:
    duty: [0.40, 0.55]
    spectral: {A1A2: 3-5}
  canter:
    duty: [0.35, 0.50]
    spectral: {A1A2: 4-6}
  gallop:
    duty: [0.30, 0.45]
    spectral: {A1A2: 5-7}
```

## Matcher
```python
class Matcher:
    def __init__(self, behavior_library):
        self.library = behavior_library
    def match(self, intent_probs, human_feats):
        scores = {}
        for b, priors in self.library.items():
            d = self.distance(human_feats, priors)
            scores[b] = intent_probs.get(b, 0) * np.exp(-d)
        # normalize
        total = sum(scores.values())
        return {k: v/total for k,v in scores.items()}
    def distance(self, feats, priors):
        # placeholder: Mahalanobis or L2 distance
        return np.linalg.norm(feats - np.array(list(priors.values())))
```

## Uncertainty Head
```python
def compute_uncertainty(intent_probs, morph_gap, temporal_mismatch, constraint_violation):
    H = - (intent_probs * np.log(intent_probs+1e-12)).sum()
    U = 0.4*H + 0.2*morph_gap + 0.2*temporal_mismatch + 0.2*constraint_violation
    return U
```
